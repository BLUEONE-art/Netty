# 2020.12.31记录

## Netty介绍

1. Netty 是由 JBOSS 提供的一个开源的 Java 框架。
2. Netty 是一个 **异步的**、基于 **事件驱动**的网络应用框架，用以快速开发高性能、高可靠性的网络 IO 程序。

  注：

+ 事件驱动比如网页上有一个按钮，可以触发一个事件，比如点击事件，这个事件会驱动/调用一个函数。
+ 异步是相对于同步而言，同步相当于浏览器发送一个请求给服务器，必须等待响应，收到响应之后才能去做其他操作；而异步不一定要等到响应回来才去做其他操作，会指定一个回调函数来处理回复的响应。

3. Netty 主要针对在 TCP 协议下，面向 Client 端的高效并发应用，或者 Peer-to-Peer 场景下的大量数据持续传输的应用。其网络框架如下：

![](Netty学习笔记.assets/Netty网络框架.png)

4. Netty 本质是一个 NIO 框架，适用于服务器通讯相关的多种应用场景。

## 应用场景

1. 分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为基础的通信组件被这些 RPC 框架使用。
2. 阿里分布式服务框架、Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，而 Netty 作为基础的通信组件，实现各个节点之间的内部通信。

# 2021.1.1记录

## I/O 模型基本说明

### 简单理解

就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。

### Java 支持的三种网络编程模型 I/O 模式

1. Java BIO：同步并阻塞(传统阻塞型)，服务器实现模式为一个连接连接一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销。

![BIO模式](C:\Users\DH\Desktop\GitHubCode\Netty\学习笔记\Netty学习笔记.assets\BIO模式.png)

缺点：

+ 如果服务器非常多的话，会存在很多很多的线程，线程会占据 CPU 资源，应对高并发的情况会有瓶颈；
+ 并不是所有线程都时时刻刻在通信，会存在线程没有进行通信却占据资源的情况；
+ 线程会阻塞。

2. Java NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求(也可以说处理多个连接、多个服务端)，即客户端发送的请求都会注册到一个多路复用器上，多路复用器轮询到连接有 I/O 请求就进行处理。

![NIO模式](C:\Users\DH\Desktop\GitHubCode\Netty\学习笔记\Netty学习笔记.assets\NIO模式.png)

3. Java AIO(NIO.2)：异步非阻塞，AIO 引入异步通道的概念，采用 Proactor 模式，简化了程序编写，有效的请求才启动线程。其特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多并且连接时间较长的应用。

### BIO、NIO、AIO的使用场景

+ BIO 适用于连接数目较小并且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 之前的唯一选择。
+ NIO 适用于==连接数目多并且连接比较短(轻操作)的架构==，比如说聊天服务器，弹幕系统，服务器间通信等。编程比较复杂。
+ AIO 适用于连接数较多并且连接时间较长(重操作)的应用。比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，KDK7 开始支持。

### Java BIO 基本介绍

+ 传统的 Java IO 编程，相关的类和接口在 java.io
+ BIO(Blocking I/O)：同步阻塞，服务器实现模式为一个连接连接一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销。==可以通过线程池机制==进行改善(实现多个客户连接服务器，==并不能减少线程数==)。

+ 适用于连接数目较小并且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 之前的唯一选择。

#### BIO 编程简单流程

+ 服务器端启动一个 ServerSocket
+ 客户端启动 Socket 对服务器进行通信，默认情况下服务器端需要对每个请求(客户)建立一个线程与之通讯
+ 客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待或者被拒绝
+ 如果有响应，客户端的线程会等待请求结束后，再继续执行

#### telnet的安装

在连接远程客户端或者测试网络时，我们在Windows上常用到Telnet连接工具，这个Telnet在Windows上是默认没有安装的。

控制面板 --->  以小图标的方式排列 ---> 程序和功能 ---> 启用或关闭 Window 应用中开启 telnet 应用

![telnet安装](C:\Users\DH\Desktop\GitHubCode\Netty\学习笔记\Netty学习笔记.assets\telnet安装.png)

连接：

```java
telnet 127.0.0.1 6666
```

传输字符串

```java
ctrl + ]
send + 发送的字符串
```

#### Java BIO 问题分析

+ 每一个请求都需要创建独立的线程，与对应的客户端进行数据 Read、业务处理和数据 Write。
+ 当并发数较大时，需要创建大量的线程来处理数据，系统资源占用大。
+ 连接建立后，如果当前线程暂时没有数据可读，则线程会阻塞在 Read 操作上，造成线程资源浪费。==说的是服务器在这里等着，直到有事情来开始做事==，就像你点菜时，服务员没把菜端上来你就一直在这里等着，啥事也干不了，不像我们可以一边等菜一边打游戏，等菜上来了，就不打游戏开始吃饭一样。

### Java NIO 基本介绍

+ Java NIO(java non-blocking IO)，是指 JDK 提供的新的 API。从 JDK1.4 开始提供的一系列改进的输入/输出的新特性，是==同步阻塞的==。
+ NIO 相关类放在 java.nio 包及子包下，对原生 java.io 包中的很多类进行了改写。
+ NIO 三大核心部分：==Channel(通道)==、==Buffer(缓冲区)== 和 ==Selector(选择器)==。
+ NIO 是面向缓冲区，或者面向 ==块==  编程。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，增加处理过程的灵活性，使用它可以提供非阻塞式的高伸缩性网络。
+ Java NIO 的非阻塞模式，使一个线程从某个通道发送或读取数据时，仅能得到目前的可用数据。如果目前没有数据可用时，此时什么都不会获取，而不是保持线程阻塞，直到数据变得可以读取之前，该线程该可以继续做其他事。非阻塞写操作也是如此，一个线程请求写入一些数据到某通道，不需要一直等到它完全写完，这个线程同时可以去做别的事情。
+ NIO 是可以用一个线程来处理多个操作的，假设有 10000 个请求过来，根据实际情况，可以分配50或者100个线程来处理。若是 BIO，则必须分配10000个线程来处理。
+ HTTP2.0 使用了多路复用的技术，做到一个连接并发处理多个请求，并且发请求的数量比 HTTP1.0 高几个数量级。

# 2021.1.3记录

![](C:\Users\DH\Desktop\GitHubCode\Netty\学习笔记\Netty学习笔记.assets\NIO 处理模式.png)

#### Selector、Channel 和 Buffer 的关系

+ 每个 Channel 都会对应于一个 Buffer。
+ Selector  对应一个线程，一个线程对应多个 Channel(连接)。
+ 该图反应了多个 Channel 注册到 Selector 程序上。
+ 程序切换到哪个 Channel 是由事件决定的，Event 就是一个重要的概念。
+ Selector 会根据不同的事件，在各个通道上切换。
+ Buffer 本质就是一个内存块，底层是有一个数组。
+ 数据的读取写入是通过 Buffer，这个和 BIO 有本质区别，BIO 中要么是输入流要么是输出流，不是双向的；但是 NIO 的 Buffer 是既可以读也可以写，需要用 flip 方法切换。
+ Channel 是双向的，可以返回底层操作系统的情况，如 Linux。

#### Buffer 的使用

+ 创建一个(int)类型的 Buffer

```java
// 创建一个 Buffer,大小为5，既可以存放5个int
IntBuffer intBuffer = IntBuffer.allocate(5);
```

+ 向 Buffer 中写入数据

```java
    // 向 Buffer 中存放数据
//        intBuffer.put(10);
//        intBuffer.put(11);
//        intBuffer.put(12);
//        intBuffer.put(13);
//        intBuffer.put(14);
    for (int i = 0; i < intBuffer.capacity(); i++) {
    intBuffer.put( i * 2);
    }
```

+ 在 Buffer 中读取数据

```java
// 从 Buffer 中读取数据
// 将 Buffer 转换，读写切换(！！！)
intBuffer.flip();

while (intBuffer.hasRemaining()) {
    System.out.println(intBuffer.get());
}
```

### NIO 和 BIO 的区别

+ BIO 是以==流==的方式处理数据，NIO 以==块==的方式处理数据，块 I/O 的效率比流 I/O 的效率高跟多。
+ BIO 是阻塞的，NIO 则是非阻塞的。
+ BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel(通道) 和 Buffer(缓冲区) 进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selector(选择器) 用于监听多个通道的事件(比如：连接请求、数据到达等)，因此使用单个线程就可以监听多个客户端通道。

### 同步、异步(针对客户端)；阻塞、非阻塞(针对服务端)的理解

**同步：**在客户端发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做，等前一件做完了才能做下一件事。

**异步：**当c端一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

**阻塞：**指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。

**非阻塞：**在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

#### 老王烧水的例子

出场人物：老王(可以理解为客户端)，水壶两把（可以理解为服务端。普通水壶，简称水壶；烧开后会响的水壶，简称响水壶）。

老王想了想，有好几种等待方式：

1. 老王用水壶烧水，并且站在那里，不管水开没开，每隔一定时间看看水开了没。**——同步阻塞**

老王想了想，这种方法不够聪明。

2. 老王还是用水壶烧水，不再傻傻的站在那里看水开，跑去卧室上网，但是还是会每隔一段时间过来看看水开了没有，水没有开就走人。**——同步非阻塞**(轮询)

老王想了想，现在的方法聪明了些，但是还是不够好。

3. 老王这次使用高大上的响水壶来烧水，还是站在那里，但是不会再每隔一段时间去看水开，而是等水开了，水壶会自动的通知他。**——异步阻塞**

老王想了想，既然水壶可以通知我，那我为什么还要傻傻的站在那里等呢，嗯，得换个方法。

4. 老王还是使用响水壶烧水，跑到卧室上网去，等着响水壶自己把水烧开了以后通知他。**——异步非阻塞**

老王豁然，这下感觉轻松了很多。

### 缓冲区(Buffer)

其本质是一个可以读写数据的内存块，可以理解为一个==容器对象(含数组)==，该对象提供了一组方法，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经过 Buffer。

+ 在 NIO 中，Buffer 是一个顶层父类，是一个抽象类。其子类有：

  ByteBuffer：     存储字节数据到缓冲区

  ShortBuffer：   存储字符串数据到缓冲区

  CharBuffer：    存储字符数据到缓冲区

  IntBuffer：        存储整数数据到缓冲区

  LongBuffer：    存储长整型数据到缓冲区

  DoubleBuffer：存储小数数据到缓冲区

  FloatBuffer：    存储小数数据到缓冲区

+ Buffer 类定义了所有缓冲区都具有四个属性来提供关于其所包含的数据元素信息：

  Capacity：容量，可以容纳的最大数据量；在缓冲区创建时确立，不可修改。

  Limit：       缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作。且极限是可以修改的。

  Position：  位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变值，为下次读写做准备

  Mark：        标记

+ Buffer.capacity()：返回缓冲区容量

  Buffer.position()：返回缓冲区的位置

  Buffer.capacity(int newPosition)：设置缓冲区的位置

  Buffer.limit()：返回缓冲区的限制

  Buffer.limit(int newLimit)：设置缓冲区的限制

  Buffer.clear：各个标志恢复到初始状态，数据没有真正擦除

+ ByteBuffer allocateDirect(int capacity)：创建直接缓冲区

  ByteBuffer allocate(int capacity)：设置初始缓冲区的容量

  ByteBuffer.get()：从当前位置 position 上get，get 之后，position 会自动 +1

  ByteBuffer.get(int index)：从指定位置上 get

  ByteBuffer.put()：从当前位置 position 上 put，put之后，position 会自动 +1

  ByteBuffer.put(int index)：从指定位置上 put

### 通道(Channel)

1. NIO 的通道类似于流，但有区别

+ 通道可以同时进行读写，而流只能读或者只能写；
+ 通道可以实现异步读写数据；
+ 通道可以从缓冲读数据，可以写数据到缓冲区

2. Channel 是 Java 的一个接口
3. 常用的 Channel 类有：FileChannel(文件数据的读写)、DatagramChannel(对 UDP 数据的读写)、ServerSocketChannel 和 SocketChannel 用于 TCP 数据的读写

#### 常用方法

+ FileChannel.read(ByteBuffer dst)：从通道读取并放到缓冲区
+ FileChannel.write(ByteBuffer src)：把缓冲区的数据写到通道中
+ FileChannel.transferFrom(ReadableByteChannel src, long position, long count)：从目标通道中复制数据到当前通道
+ FileChannel.transferTo(long position, long count, WriteableByteChannel target )：把数据从当前通道复制给目标通道

# IDEA 常用操作

+ 选中类 ---> Ctrl + H：查看该类的子类